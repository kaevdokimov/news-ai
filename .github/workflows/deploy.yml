name: Deploy to Production
permissions:
    contents: read
    packages: write

on:
    push:
        branches: ["main"]
    workflow_dispatch:

jobs:
    deploy:
        runs-on: ubuntu-latest

        steps:
            - uses: actions/checkout@v6

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v2

            - name: Login to Docker Registry
              uses: docker/login-action@v2
              with:
                  registry: ${{ vars.DOCKER_REGISTRY }}
                  username: ${{ vars.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_PASSWORD }}

            - name: Build and push Docker image
              uses: docker/build-push-action@v4
              with:
                  context: .
                  file: .docker/app/DockerfileProduction
                  push: true
                  tags: |
                      ${{ vars.DOCKER_REGISTRY }}/${{ vars.DOCKER_USERNAME }}/news-ai:latest
                      ${{ vars.DOCKER_REGISTRY }}/${{ vars.DOCKER_USERNAME }}/news-ai:${{ github.sha }}
                  cache-from: type=registry,ref=${{ vars.DOCKER_REGISTRY }}/${{ vars.DOCKER_USERNAME }}/news-ai:latest
                  cache-to: type=inline

            - name: Setup SSH connection
              run: |
                  mkdir -p ~/.ssh
                  echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_ecdsa
                  chmod 600 ~/.ssh/id_ecdsa
                  ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

            -   name: Create .env file
                run: |
                    cat > .env << 'EOL'
                    # Application
                    APP_ENV=${{ secrets.APP_ENV }}
                    APP_SECRET=${{ secrets.APP_SECRET }}
                    DEFAULT_URI=${{ secrets.DEFAULT_URI }}

                    # Database
                    POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
                    POSTGRES_USER=${{ secrets.POSTGRES_USER }}
                    POSTGRES_DB=${{ secrets.POSTGRES_DB }}
                    POSTGRES_VERSION=${{ vars.POSTGRES_VERSION }}

                    # RabbitMQ
                    RABBITMQ_DEFAULT_PASS=${{ secrets.RABBITMQ_DEFAULT_PASS }}
                    RABBITMQ_USER=${{ secrets.RABBITMQ_USER }}
                    RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}
                    RABBITMQ_SERVER_VERSION=${{ vars.RABBITMQ_SERVER_VERSION }}

                    # Docker
                    DOCKER_REGISTRY=${{ vars.DOCKER_REGISTRY }}
                    DOCKER_USERNAME=${{ vars.DOCKER_USERNAME }}
                    COMPOSE_PROJECT_NAME=${{ vars.COMPOSE_PROJECT_NAME }}
                    EOL

            -   name: Deploy to server
                env:
                    DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
                    DOCKER_IMAGE: ghcr.io/kaevdokimov/news-ai:latest
                    SSH_USER: ${{ secrets.SSH_USERNAME }}
                    SSH_HOST: ${{ secrets.SSH_HOST }}
                    SSH_PORT: ${{ secrets.SSH_PORT }}
                run: |
                    # Подготовка SSH ключа
                    mkdir -p ~/.ssh
                    echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_ecdsa
                    chmod 600 ~/.ssh/id_ecdsa
                    ssh-keyscan -p $SSH_PORT $SSH_HOST >> ~/.ssh/known_hosts

                    # Создание необходимых директорий на сервере
                    ssh -p $SSH_PORT $SSH_USER@$SSH_HOST "
                      set -e
                      mkdir -p $DEPLOY_PATH
                      mkdir -p $DEPLOY_PATH/certbot/conf
                      mkdir -p $DEPLOY_PATH/certbot/www
                    "

                    # Копирование только необходимых файлов
                    scp -P $SSH_PORT compose-production.yaml $SSH_USER@$SSH_HOST:$DEPLOY_PATH/
                    scp -P $SSH_PORT .env $SSH_USER@$SSH_HOST:$DEPLOY_PATH/.env

                    # Выполнение команд на сервере в одной SSH сессии
                    ssh -p $SSH_PORT $SSH_USER@$SSH_HOST "
                      set -e

                      echo '✅ SSH connection successful'
                      mkdir -p $DEPLOY_PATH/certbot/conf $DEPLOY_PATH/certbot/www

                      cd $DEPLOY_PATH

                      # Войти в GHCR с использованием GITHUB_TOKEN
                      echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

                      # Установить правильный тег образа
                      export DOCKER_IMAGE=ghcr.io/kaevdokimov/news-ai:latest

                      docker-compose -f compose-production.yaml down -v --remove-orphans || true
                      docker ps -aq --no-trunc | xargs -r docker rm -f || true
                      docker-compose -f compose-production.yaml up -d

                      # Очищаем неиспользуемые образы
                      docker image prune -af

                      # SSL: проверка сертификатов и получение новых, если нужно
                      if [ ! -f '$DEPLOY_PATH/certbot/conf/live/signalscan.ru/fullchain.pem' ]; then
                        echo 'Generating dummy certificates...'
                        mkdir -p $DEPLOY_PATH/certbot/conf/live/signalscan.ru
                        openssl req -x509 -nodes -newkey rsa:2048 -days 1 \
                          -keyout '$DEPLOY_PATH/certbot/conf/live/signalscan.ru/privkey.pem' \
                          -out '$DEPLOY_PATH/certbot/conf/live/signalscan.ru/fullchain.pem' \
                          -subj '/CN=localhost'
                        docker compose -f compose-production.yaml up -d news_ai_nginx
                        sleep 5
                        docker run --rm -v '$DEPLOY_PATH/certbot/conf:/etc/letsencrypt' -v '$DEPLOY_PATH/certbot/www:/var/www/certbot' \
                          certbot/certbot certonly --webroot --webroot-path=/var/www/certbot --email admin@signalscan.ru --agree-tos --no-eff-email -d signalscan.ru -d www.signalscan.ru
                      else
                        echo 'Renewing existing certificates...'
                        docker run --rm -v '$DEPLOY_PATH/certbot/conf:/etc/letsencrypt' -v '$DEPLOY_PATH/certbot/www:/var/www/certbot' \
                          certbot/certbot renew
                      fi

                      # Перезагрузить nginx
                      docker compose -f compose-production.yaml exec news_ai_nginx nginx -s reload || echo '⚠️ Failed to reload nginx'
                    "
